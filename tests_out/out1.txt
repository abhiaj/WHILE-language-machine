Standard ML of New Jersey v110.79 [built: Sat Oct 26 12:27:04 2019]
[opening while_ast.sml]
[autoloading]
[library $SMLNJ-BASIS/basis.cm is stable]
[library $SMLNJ-BASIS/(basis.cm):basis-common.cm is stable]
[autoloading done]
val argv = ["test_cases/test1.txt"] : string list
[autoloading]
[library $smlnj/compiler/current.cm is stable]
[library $smlnj/compiler/x86.cm is stable]
[library $smlnj/viscomp/core.cm is stable]
[library $smlnj/viscomp/basics.cm is stable]
[library $smlnj/viscomp/elabdata.cm is stable]
[library $smlnj/viscomp/elaborate.cm is stable]
[library $smlnj/MLRISC/Lib.cm is stable]
[library $SMLNJ-MLRISC/Lib.cm is stable]
[library $smlnj/smlnj-lib/pp-lib.cm is stable]
[library $SMLNJ-LIB/PP/pp-lib.cm is stable]
[library $html-lib.cm(=$SMLNJ-LIB/HTML)/html-lib.cm is stable]
[library $smlnj-lib.cm(=$SMLNJ-LIB/Util)/smlnj-lib.cm is stable]
[library $smlnj/viscomp/debugprof.cm is stable]
[library $smlnj/MLRISC/Control.cm is stable]
[library $SMLNJ-MLRISC/Control.cm is stable]
[library $controls-lib.cm(=$SMLNJ-LIB/Controls)/controls-lib.cm is stable]
[library $smlnj/smlnj-lib/controls-lib.cm is stable]
[autoloading done]
val it = () : unit
val it = () : unit
val it = () : unit
[autoloading]
[library $smlnj/cm/cm.cm is stable]
[library $smlnj/internal/cm-sig-lib.cm is stable]
[library $/pgraph.cm is stable]
[library $smlnj/internal/srcpath-lib.cm is stable]
[autoloading done]
[New bindings added.]
val it = true : bool
[library $/ml-yacc-lib.cm is stable]
[library $SMLNJ-ML-YACC-LIB/ml-yacc-lib.cm is stable]
[New bindings added.]
val it = true : bool
[scanning sources.cm]
[attempting to load plugin $/lex-ext.cm]
[library $/lex-ext.cm is stable]
[library $smlnj/cm/tools.cm is stable]
[library $smlnj/internal/cm-lib.cm is stable]
[plugin $/lex-ext.cm loaded successfully]
[attempting to load plugin $/mllex-tool.cm]
[library $/mllex-tool.cm is stable]
[plugin $/mllex-tool.cm loaded successfully]
[attempting to load plugin $/grm-ext.cm]
[library $/grm-ext.cm is stable]
[plugin $/grm-ext.cm loaded successfully]
[attempting to load plugin $/mlyacc-tool.cm]
[library $/mlyacc-tool.cm is stable]
[plugin $/mlyacc-tool.cm loaded successfully]
[loading (sources.cm):prog.grm.sig]
[loading (sources.cm):AST.sml]
[loading (sources.cm):prog.grm.sml]
[loading (sources.cm):prog.lex.sml]
[loading (sources.cm):parse.sml]
[New bindings added.]
val it = true : bool
[opening AST.sml]
AST.sml:120.9-125.115 Warning: match nonexhaustive
          SET (str,exp) => ...
          READ str => ...
          WRITE exp => ...
          ITE (exp,CommL1,CommL2) => ...
          WHILE (exp,CommL) => ...
  
AST.sml:92.9-114.92 Warning: match nonexhaustive
          INTEGER int => ...
          ID x => ...
          PLUS (exp1,exp2) => ...
          MINUS (exp1,exp2) => ...
          TIMES (exp1,exp2) => ...
          DIV (exp1,exp2) => ...
          MOD (exp1,exp2) => ...
          NEG exp => ...
          TT => ...
          FF => ...
          IDB x => ...
          AND (exp1,exp2) => ...
          OR (exp1,exp2) => ...
          NOT exp => ...
          GT (exp1,exp2) => ...
          LT (exp1,exp2) => ...
          GTE (exp1,exp2) => ...
          LTE (exp1,exp2) => ...
          EQ (exp1,exp2) => ...
          NEQ (exp1,exp2) => ...
  
structure AST :
  sig
    type VARIABLE = string
    datatype IEXP = ...
    datatype BEXP
      = EQB of BEXP * BEXP
      | GTB of BEXP * BEXP
      | GTEB of BEXP * BEXP
      | LTB of BEXP * BEXP
      | LTEB of BEXP * BEXP
      | NEQB of BEXP * BEXP
      ... 
    datatype EXP
      = AND of EXP * EXP
      | BEXP of EXP
      | DIV of EXP * EXP
      | EQ of EXP * EXP
      | ERROR
      | FF
      | GT of EXP * EXP
      | GTE of EXP * EXP
      | ID of VARIABLE
      | IDB of VARIABLE
      | IEXP of EXP
      | INTEGER of int
      | LT of EXP * EXP
      | LTE of EXP * EXP
      | MINUS of EXP * EXP
      | MOD of EXP * EXP
      | NEG of EXP
      | NEQ of EXP * EXP
      | NOT of EXP
      | OR of EXP * EXP
      | PLUS of EXP * EXP
      | TIMES of EXP * EXP
      | TT
    datatype COMMAND
      = ERROR2
      | ITE of EXP * COMMAND list * COMMAND list
      | READ of string
      | SET of string * EXP
      | WHILE of EXP * COMMAND list
      | WRITE of EXP
    datatype TYPE = BOOL | INT
    datatype DECLARATION = DECL of string list * TYPE
    datatype PROGRAM = PROG of string * DECLARATION list * COMMAND list
    exception ScanError
    exception ParseError
    val listToPostfix : string list -> string
    val ExpToPostfix : EXP -> string
    val CommToPostfix : COMMAND -> string
    val CommListToPostfix : COMMAND list -> string
    val DeclToPostfix : DECLARATION -> string
    val DeclListToPostfix : DECLARATION list -> string
    val postfix : PROGRAM -> string
  end
val it = () : unit
[opening prog.grm.sig]
signature C_TOKENS =
  sig
    type ('a,'b) token
    type svalue
    val NEG : 'a * 'a -> (svalue,'a) token
    val NUMBER : int * 'a * 'a -> (svalue,'a) token
    val IDENTIFIER : string * 'a * 'a -> (svalue,'a) token
    val WRITE : 'a * 'a -> (svalue,'a) token
    val READ : 'a * 'a -> (svalue,'a) token
    val SCOLON : 'a * 'a -> (svalue,'a) token
    val MOD : 'a * 'a -> (svalue,'a) token
    val DIV : 'a * 'a -> (svalue,'a) token
    val MUL : 'a * 'a -> (svalue,'a) token
    val MINUS : 'a * 'a -> (svalue,'a) token
    val PLUS : 'a * 'a -> (svalue,'a) token
    val NEQ : 'a * 'a -> (svalue,'a) token
    val EQ : 'a * 'a -> (svalue,'a) token
    val GTE : 'a * 'a -> (svalue,'a) token
    val LTE : 'a * 'a -> (svalue,'a) token
    val GT : 'a * 'a -> (svalue,'a) token
    val LT : 'a * 'a -> (svalue,'a) token
    val NOT : 'a * 'a -> (svalue,'a) token
    val FALSE : 'a * 'a -> (svalue,'a) token
    val TRUE : 'a * 'a -> (svalue,'a) token
    val AND : 'a * 'a -> (svalue,'a) token
    val OR : 'a * 'a -> (svalue,'a) token
    val RPAREN : 'a * 'a -> (svalue,'a) token
    val LPAREN : 'a * 'a -> (svalue,'a) token
    val ENDWH : 'a * 'a -> (svalue,'a) token
    val DO : 'a * 'a -> (svalue,'a) token
    val WHILE : 'a * 'a -> (svalue,'a) token
    val ENDIF : 'a * 'a -> (svalue,'a) token
    val ELSE : 'a * 'a -> (svalue,'a) token
    val THEN : 'a * 'a -> (svalue,'a) token
    val IF : 'a * 'a -> (svalue,'a) token
    val ASSIGN : 'a * 'a -> (svalue,'a) token
    val RCPAREN : 'a * 'a -> (svalue,'a) token
    val LCPAREN : 'a * 'a -> (svalue,'a) token
    val COMMA : 'a * 'a -> (svalue,'a) token
    val BOOL : 'a * 'a -> (svalue,'a) token
    val INT : 'a * 'a -> (svalue,'a) token
    val VAR : 'a * 'a -> (svalue,'a) token
    val COLON : 'a * 'a -> (svalue,'a) token
    val DCOLON : 'a * 'a -> (svalue,'a) token
    val PROGRAM : 'a * 'a -> (svalue,'a) token
    val EOF : 'a * 'a -> (svalue,'a) token
  end
signature C_LRVALS =
  sig
    structure Tokens :
      sig
        type ('a,'b) token
        type svalue
        val NEG : 'a * 'a -> (svalue,'a) token
        val NUMBER : int * 'a * 'a -> (svalue,'a) token
        val IDENTIFIER : string * 'a * 'a -> (svalue,'a) token
        val WRITE : 'a * 'a -> (svalue,'a) token
        val READ : 'a * 'a -> (svalue,'a) token
        val SCOLON : 'a * 'a -> (svalue,'a) token
        val MOD : 'a * 'a -> (svalue,'a) token
        val DIV : 'a * 'a -> (svalue,'a) token
        val MUL : 'a * 'a -> (svalue,'a) token
        val MINUS : 'a * 'a -> (svalue,'a) token
        val PLUS : 'a * 'a -> (svalue,'a) token
        val NEQ : 'a * 'a -> (svalue,'a) token
        val EQ : 'a * 'a -> (svalue,'a) token
        val GTE : 'a * 'a -> (svalue,'a) token
        val LTE : 'a * 'a -> (svalue,'a) token
        val GT : 'a * 'a -> (svalue,'a) token
        val LT : 'a * 'a -> (svalue,'a) token
        val NOT : 'a * 'a -> (svalue,'a) token
        val FALSE : 'a * 'a -> (svalue,'a) token
        val TRUE : 'a * 'a -> (svalue,'a) token
        val AND : 'a * 'a -> (svalue,'a) token
        val OR : 'a * 'a -> (svalue,'a) token
        val RPAREN : 'a * 'a -> (svalue,'a) token
        val LPAREN : 'a * 'a -> (svalue,'a) token
        val ENDWH : 'a * 'a -> (svalue,'a) token
        val DO : 'a * 'a -> (svalue,'a) token
        val WHILE : 'a * 'a -> (svalue,'a) token
        val ENDIF : 'a * 'a -> (svalue,'a) token
        val ELSE : 'a * 'a -> (svalue,'a) token
        val THEN : 'a * 'a -> (svalue,'a) token
        val IF : 'a * 'a -> (svalue,'a) token
        val ASSIGN : 'a * 'a -> (svalue,'a) token
        val RCPAREN : 'a * 'a -> (svalue,'a) token
        val LCPAREN : 'a * 'a -> (svalue,'a) token
        val COMMA : 'a * 'a -> (svalue,'a) token
        val BOOL : 'a * 'a -> (svalue,'a) token
        val INT : 'a * 'a -> (svalue,'a) token
        val VAR : 'a * 'a -> (svalue,'a) token
        val COLON : 'a * 'a -> (svalue,'a) token
        val DCOLON : 'a * 'a -> (svalue,'a) token
        val PROGRAM : 'a * 'a -> (svalue,'a) token
        val EOF : 'a * 'a -> (svalue,'a) token
      end
    structure ParserData :
      sig
        type pos
        type svalue
        type arg
        type result
        structure LrTable : <sig>
        structure Token : <sig>
        structure Actions : <sig>
        structure EC : <sig>
        val table : LrTable.table
        sharing LrTable = Token.LrTable
      end
    sharing type Tokens.svalue = ParserData.svalue
    sharing type Tokens.token = ParserData.Token.token
  end
val it = () : unit
[opening prog.grm.sml]
[autoloading]
[autoloading done]
functor CLrValsFun(<param>: sig
                              structure Token : <sig>
                            end) :
                  sig
                    structure ParserData : <sig>
                    structure Tokens : <sig>
                  end
val it = () : unit
[opening prog.lex.sml]
functor CLexFun(<param>: sig
                           structure Tokens : <sig>
                         end) :
               sig
                 structure yyInput : <sig>
                 type yystart_state
                 structure UserDeclarations : <sig>
                 type yymatch
                 type action
                 val makeLexer : (int -> string)
                                 -> unit -> UserDeclarations.lexresult
                 val makeLexer' : (int -> string)
                                  -> unit -> UserDeclarations.lexresult
               end
val it = () : unit
[opening parse.sml]
structure Parser :
  sig
    structure CLrVals : <sig>
    structure CLex : <sig>
    structure CParser : <sig>
    exception CError
    val parse : string -> CParser.result
  end
val it = () : unit
[opening vmc.sml]
[opening stack.sml]
signature Stack =
  sig
    type 'a Stack
    exception EmptyStack
    exception Error of string
    val create : 'a Stack
    val push : 'a * 'a Stack -> 'a Stack
    val pop : 'a Stack -> 'a Stack
    val top : 'a Stack -> 'a
    val empty : 'a Stack -> bool
    val poptop : 'a Stack -> ('a * 'a Stack) option
    val nth : 'a Stack * int -> 'a
    val drop : 'a Stack * int -> 'a Stack
    val depth : 'a Stack -> int
    val app : ('a -> unit) -> 'a Stack -> unit
    val map : ('a -> 'b) -> 'a Stack -> 'b Stack
    val mapPartial : ('a -> 'b option) -> 'a Stack -> 'b Stack
    val find : ('a -> bool) -> 'a Stack -> 'a option
    val filter : ('a -> bool) -> 'a Stack -> 'a Stack
    val foldr : ('a * 'b -> 'b) -> 'b -> 'a Stack -> 'b
    val foldl : ('a * 'b -> 'b) -> 'b -> 'a Stack -> 'b
    val exists : ('a -> bool) -> 'a Stack -> bool
    val all : ('a -> bool) -> 'a Stack -> bool
    val List2Stack : 'a list -> 'a Stack
    val Stack2List : 'a Stack -> 'a list
    val toString : ('a -> string) -> 'a Stack -> string
  end
structure FunStack : Stack
val it = () : unit
vmc.sml:89.9-100.44 Warning: match nonexhaustive
          (var :: list,1) => ...
          (var :: list,0) => ...
          (nil,var_type) => ...
  
vmc.sml:58.28 Warning: calling polyEqual
structure Vmc :
  sig
    exception VMCERROR
    exception BOOLERROR
    exception DUPVARERROR
    val mem_size : int
    val garbage : int
    val memory : int array
    val index : int ref
    val printList : string list -> string
    val exist : ''a * ''a list -> bool
    val delete_ith : 'a list * int -> 'a list
    structure StrHashmap : <sig>
    val symTbl : int StrHashmap.hash_table
    val var_int_list : string list ref
    val var_bool_list : string list ref
    val err_msg : string -> unit
    val check : string -> int
    val insert_list : string list * int -> bool
    val fill_helper : AST.DECLARATION -> bool
    val fill_list : AST.DECLARATION list -> bool
    val fill_symbol_table : AST.PROGRAM -> bool
    val string_var_list : int array * string list -> string
    val Id : 'a -> 'a
    val toString : string FunStack.Stack * int array * string FunStack.Stack
                   -> unit
    val Vstack : 'a FunStack.Stack
    val Cstack : 'a FunStack.Stack
    val eval : int * int * string -> int
    val eval_1op : int * string -> int
    val get_comm_list1 : string FunStack.Stack * int
                         -> string FunStack.Stack * string list
    val get_comm_list2 : string FunStack.Stack * int
                         -> string FunStack.Stack * string list
    val get_comm_list3 : string FunStack.Stack * int
                         -> string FunStack.Stack * string list
    val get_comm_list4 : string FunStack.Stack * int
                         -> string FunStack.Stack * string list
    val push_list_on_stack : 'a FunStack.Stack * 'a list -> 'a FunStack.Stack
    val get_input : string -> string
    val rules : string FunStack.Stack * int array * string FunStack.Stack
                -> string FunStack.Stack * int array * string FunStack.Stack
  end
val it = () : unit
opening Vmc
  exception VMCERROR
  exception BOOLERROR
  exception DUPVARERROR
  val mem_size : int
  val garbage : int
  val memory : int array
  val index : int ref
  val printList : string list -> string
  val exist : ''a * ''a list -> bool
  val delete_ith : 'a list * int -> 'a list
  structure StrHashmap :
    sig
      structure Key : <sig>
      datatype 'a hash_table = ...
      val mkTable : int * exn -> 'a hash_table
      val clear : 'a hash_table -> unit
      val insert : 'a hash_table -> Key.hash_key * 'a -> unit
      val inDomain : 'a hash_table -> Key.hash_key -> bool
      val lookup : 'a hash_table -> Key.hash_key -> 'a
      val find : 'a hash_table -> Key.hash_key -> 'a option
      val remove : 'a hash_table -> Key.hash_key -> 'a
      val numItems : 'a hash_table -> int
      val listItems : 'a hash_table -> 'a list
      val listItemsi : 'a hash_table -> (Key.hash_key * 'a) list
      val app : ('a -> unit) -> 'a hash_table -> unit
      val appi : (Key.hash_key * 'a -> unit) -> 'a hash_table -> unit
      val map : ('a -> 'b) -> 'a hash_table -> 'b hash_table
      val mapi : (Key.hash_key * 'a -> 'b) -> 'a hash_table -> 'b hash_table
      val fold : ('a * 'b -> 'b) -> 'b -> 'a hash_table -> 'b
      val foldi : (Key.hash_key * 'a * 'b -> 'b) -> 'b -> 'a hash_table -> 'b
      val modify : ('a -> 'a) -> 'a hash_table -> unit
      val modifyi : (Key.hash_key * 'a -> 'a) -> 'a hash_table -> unit
      val filter : ('a -> bool) -> 'a hash_table -> unit
      val filteri : (Key.hash_key * 'a -> bool) -> 'a hash_table -> unit
      val copy : 'a hash_table -> 'a hash_table
      val bucketSizes : 'a hash_table -> int list
    end
  val symTbl : int Vmc.StrHashmap.hash_table
  val var_int_list : string list ref
  val var_bool_list : string list ref
  val err_msg : string -> unit
  val check : string -> int
  val insert_list : string list * int -> bool
  val fill_helper : AST.DECLARATION -> bool
  val fill_list : AST.DECLARATION list -> bool
  val fill_symbol_table : AST.PROGRAM -> bool
  val string_var_list : int array * string list -> string
  val Id : 'a -> 'a
  val toString : string FunStack.Stack * int array * string FunStack.Stack
                 -> unit
  val Vstack : 'a FunStack.Stack
  val Cstack : 'a FunStack.Stack
  val eval : int * int * string -> int
  val eval_1op : int * string -> int
  val get_comm_list1 : string FunStack.Stack * int
                       -> string FunStack.Stack * string list
  val get_comm_list2 : string FunStack.Stack * int
                       -> string FunStack.Stack * string list
  val get_comm_list3 : string FunStack.Stack * int
                       -> string FunStack.Stack * string list
  val get_comm_list4 : string FunStack.Stack * int
                       -> string FunStack.Stack * string list
  val push_list_on_stack : 'a FunStack.Stack * 'a list -> 'a FunStack.Stack
  val get_input : string -> string
  val rules : string FunStack.Stack * int array * string FunStack.Stack
              -> string FunStack.Stack * int array * string FunStack.Stack



######


val execute = fn
  : string FunStack.Stack * int array * string FunStack.Stack
    -> string FunStack.Stack * int array * string FunStack.Stack
val parseOutput =
  PROG
    ("Greater",[DECL (["A","B"],INT)],
     [READ "A",READ "B",
      ITE (GT (ID "A",ID "B"),[WRITE (ID "A")],[WRITE (ID "B")])])
  : Parser.CParser.result
val str_postfix =
  "A READ B READ A ID B ID GT IF A ID WRITE  THEN B ID WRITE  ELSE " : string
val spaceSep = fn : string -> string list
val str_postfix_list =
  ["A","READ","B","READ","A","ID","B","ID","GT","IF","A","ID","WRITE","THEN",
   "B","ID","WRITE","ELSE"] : string list
val Cstack = - : string FunStack.Stack
Input A: 